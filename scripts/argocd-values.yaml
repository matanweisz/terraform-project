server:
  service:
    type: ClusterIP
    servicePort: 80 # ALB expects port 80 (backend-protocol: HTTP)
    targetPort: 8080 # ArgoCD default internal port

  ingress:
    enabled: true
    ingressClassName: alb
    annotations:
      # AWS Load Balancer Controller annotations
      # IMPORTANT: Group all internal cluster apps on single ALB to save costs
      alb.ingress.kubernetes.io/group.name: internal-cluster-apps
      alb.ingress.kubernetes.io/scheme: internet-facing
      alb.ingress.kubernetes.io/target-type: ip
      # SSL/TLS Configuration
      alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS": 443}]'
      alb.ingress.kubernetes.io/ssl-redirect: "443"
      alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:eu-central-1:536697238781:certificate/8607b974-4f40-4469-b9d0-2ce7aae96a19
      # Health check configuration for ArgoCD
      alb.ingress.kubernetes.io/healthcheck-path: /healthz
      alb.ingress.kubernetes.io/healthcheck-protocol: HTTP
      alb.ingress.kubernetes.io/healthcheck-port: "8080"
      # Backend protocol (HTTP since ArgoCD server runs with --insecure)
      alb.ingress.kubernetes.io/backend-protocol: HTTP
    hostname: argocd.matanweisz.xyz
    path: /
    pathType: Prefix
    tls: true

  extraArgs:
    - --insecure # Required because ALB communicates on HTTP

  replicas: 1 # Change for high availability

  resources:
    requests:
      cpu: 100m
      memory: 512Mi
    limits:
      cpu: 500m
      memory: 1Gi

controller:
  replicas: 2

repoServer:
  replicas: 2

configs:
  params:
    server.insecure: true

# Expose health check endpoint for ALB
serverConfig:
  server:
    insecure: true

applicationSet:
  enabled: true

dex:
  enabled: true

redis:
  enabled: true
